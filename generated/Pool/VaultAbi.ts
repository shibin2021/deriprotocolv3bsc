// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class VaultAbi__getBalancesResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class VaultAbi extends ethereum.SmartContract {
  static bind(address: Address): VaultAbi {
    return new VaultAbi("VaultAbi", address);
  }

  comptroller(): Address {
    let result = super.call("comptroller", "comptroller():(address)", []);

    return result[0].toAddress();
  }

  try_comptroller(): ethereum.CallResult<Address> {
    let result = super.tryCall("comptroller", "comptroller():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getBalances(vToken: Address): VaultAbi__getBalancesResult {
    let result = super.call(
      "getBalances",
      "getBalances(address):(uint256,uint256)",
      [ethereum.Value.fromAddress(vToken)]
    );

    return new VaultAbi__getBalancesResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getBalances(
    vToken: Address
  ): ethereum.CallResult<VaultAbi__getBalancesResult> {
    let result = super.tryCall(
      "getBalances",
      "getBalances(address):(uint256,uint256)",
      [ethereum.Value.fromAddress(vToken)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new VaultAbi__getBalancesResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  getHypotheticalVaultLiquidity(
    vTokenModify: Address,
    redeemVTokens: BigInt
  ): BigInt {
    let result = super.call(
      "getHypotheticalVaultLiquidity",
      "getHypotheticalVaultLiquidity(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(vTokenModify),
        ethereum.Value.fromUnsignedBigInt(redeemVTokens)
      ]
    );

    return result[0].toBigInt();
  }

  try_getHypotheticalVaultLiquidity(
    vTokenModify: Address,
    redeemVTokens: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getHypotheticalVaultLiquidity",
      "getHypotheticalVaultLiquidity(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(vTokenModify),
        ethereum.Value.fromUnsignedBigInt(redeemVTokens)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getMarketsIn(): Array<Address> {
    let result = super.call("getMarketsIn", "getMarketsIn():(address[])", []);

    return result[0].toAddressArray();
  }

  try_getMarketsIn(): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "getMarketsIn",
      "getMarketsIn():(address[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  getVaultLiquidity(): BigInt {
    let result = super.call(
      "getVaultLiquidity",
      "getVaultLiquidity():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_getVaultLiquidity(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getVaultLiquidity",
      "getVaultLiquidity():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isInMarket(vToken: Address): boolean {
    let result = super.call("isInMarket", "isInMarket(address):(bool)", [
      ethereum.Value.fromAddress(vToken)
    ]);

    return result[0].toBoolean();
  }

  try_isInMarket(vToken: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall("isInMarket", "isInMarket(address):(bool)", [
      ethereum.Value.fromAddress(vToken)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  nameId(): Bytes {
    let result = super.call("nameId", "nameId():(bytes32)", []);

    return result[0].toBytes();
  }

  try_nameId(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("nameId", "nameId():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  pool(): Address {
    let result = super.call("pool", "pool():(address)", []);

    return result[0].toAddress();
  }

  try_pool(): ethereum.CallResult<Address> {
    let result = super.tryCall("pool", "pool():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  tokenXVS(): Address {
    let result = super.call("tokenXVS", "tokenXVS():(address)", []);

    return result[0].toAddress();
  }

  try_tokenXVS(): ethereum.CallResult<Address> {
    let result = super.tryCall("tokenXVS", "tokenXVS():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  transferAll(underlying: Address, to: Address): BigInt {
    let result = super.call(
      "transferAll",
      "transferAll(address,address):(uint256)",
      [ethereum.Value.fromAddress(underlying), ethereum.Value.fromAddress(to)]
    );

    return result[0].toBigInt();
  }

  try_transferAll(
    underlying: Address,
    to: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "transferAll",
      "transferAll(address,address):(uint256)",
      [ethereum.Value.fromAddress(underlying), ethereum.Value.fromAddress(to)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  vTokenETH(): Address {
    let result = super.call("vTokenETH", "vTokenETH():(address)", []);

    return result[0].toAddress();
  }

  try_vTokenETH(): ethereum.CallResult<Address> {
    let result = super.tryCall("vTokenETH", "vTokenETH():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  vaultLiquidityMultiplier(): BigInt {
    let result = super.call(
      "vaultLiquidityMultiplier",
      "vaultLiquidityMultiplier():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_vaultLiquidityMultiplier(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "vaultLiquidityMultiplier",
      "vaultLiquidityMultiplier():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  versionId(): Bytes {
    let result = super.call("versionId", "versionId():(bytes32)", []);

    return result[0].toBytes();
  }

  try_versionId(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("versionId", "versionId():(bytes32)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get pool_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get comptroller_(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get vTokenETH_(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get vaultLiquidityMultiplier_(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ClaimVenusCall extends ethereum.Call {
  get inputs(): ClaimVenusCall__Inputs {
    return new ClaimVenusCall__Inputs(this);
  }

  get outputs(): ClaimVenusCall__Outputs {
    return new ClaimVenusCall__Outputs(this);
  }
}

export class ClaimVenusCall__Inputs {
  _call: ClaimVenusCall;

  constructor(call: ClaimVenusCall) {
    this._call = call;
  }

  get account(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ClaimVenusCall__Outputs {
  _call: ClaimVenusCall;

  constructor(call: ClaimVenusCall) {
    this._call = call;
  }
}

export class EnterMarketCall extends ethereum.Call {
  get inputs(): EnterMarketCall__Inputs {
    return new EnterMarketCall__Inputs(this);
  }

  get outputs(): EnterMarketCall__Outputs {
    return new EnterMarketCall__Outputs(this);
  }
}

export class EnterMarketCall__Inputs {
  _call: EnterMarketCall;

  constructor(call: EnterMarketCall) {
    this._call = call;
  }

  get vToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class EnterMarketCall__Outputs {
  _call: EnterMarketCall;

  constructor(call: EnterMarketCall) {
    this._call = call;
  }
}

export class ExitMarketCall extends ethereum.Call {
  get inputs(): ExitMarketCall__Inputs {
    return new ExitMarketCall__Inputs(this);
  }

  get outputs(): ExitMarketCall__Outputs {
    return new ExitMarketCall__Outputs(this);
  }
}

export class ExitMarketCall__Inputs {
  _call: ExitMarketCall;

  constructor(call: ExitMarketCall) {
    this._call = call;
  }

  get vToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ExitMarketCall__Outputs {
  _call: ExitMarketCall;

  constructor(call: ExitMarketCall) {
    this._call = call;
  }
}

export class MintCall extends ethereum.Call {
  get inputs(): MintCall__Inputs {
    return new MintCall__Inputs(this);
  }

  get outputs(): MintCall__Outputs {
    return new MintCall__Outputs(this);
  }
}

export class MintCall__Inputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }
}

export class MintCall__Outputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }
}

export class Mint1Call extends ethereum.Call {
  get inputs(): Mint1Call__Inputs {
    return new Mint1Call__Inputs(this);
  }

  get outputs(): Mint1Call__Outputs {
    return new Mint1Call__Outputs(this);
  }
}

export class Mint1Call__Inputs {
  _call: Mint1Call;

  constructor(call: Mint1Call) {
    this._call = call;
  }

  get vToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class Mint1Call__Outputs {
  _call: Mint1Call;

  constructor(call: Mint1Call) {
    this._call = call;
  }
}

export class RedeemCall extends ethereum.Call {
  get inputs(): RedeemCall__Inputs {
    return new RedeemCall__Inputs(this);
  }

  get outputs(): RedeemCall__Outputs {
    return new RedeemCall__Outputs(this);
  }
}

export class RedeemCall__Inputs {
  _call: RedeemCall;

  constructor(call: RedeemCall) {
    this._call = call;
  }

  get vToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RedeemCall__Outputs {
  _call: RedeemCall;

  constructor(call: RedeemCall) {
    this._call = call;
  }
}

export class RedeemAllCall extends ethereum.Call {
  get inputs(): RedeemAllCall__Inputs {
    return new RedeemAllCall__Inputs(this);
  }

  get outputs(): RedeemAllCall__Outputs {
    return new RedeemAllCall__Outputs(this);
  }
}

export class RedeemAllCall__Inputs {
  _call: RedeemAllCall;

  constructor(call: RedeemAllCall) {
    this._call = call;
  }

  get vToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class RedeemAllCall__Outputs {
  _call: RedeemAllCall;

  constructor(call: RedeemAllCall) {
    this._call = call;
  }
}

export class RedeemUnderlyingCall extends ethereum.Call {
  get inputs(): RedeemUnderlyingCall__Inputs {
    return new RedeemUnderlyingCall__Inputs(this);
  }

  get outputs(): RedeemUnderlyingCall__Outputs {
    return new RedeemUnderlyingCall__Outputs(this);
  }
}

export class RedeemUnderlyingCall__Inputs {
  _call: RedeemUnderlyingCall;

  constructor(call: RedeemUnderlyingCall) {
    this._call = call;
  }

  get vToken(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RedeemUnderlyingCall__Outputs {
  _call: RedeemUnderlyingCall;

  constructor(call: RedeemUnderlyingCall) {
    this._call = call;
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get underlying(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }
}

export class TransferAllCall extends ethereum.Call {
  get inputs(): TransferAllCall__Inputs {
    return new TransferAllCall__Inputs(this);
  }

  get outputs(): TransferAllCall__Outputs {
    return new TransferAllCall__Outputs(this);
  }
}

export class TransferAllCall__Inputs {
  _call: TransferAllCall;

  constructor(call: TransferAllCall) {
    this._call = call;
  }

  get underlying(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }
}

export class TransferAllCall__Outputs {
  _call: TransferAllCall;

  constructor(call: TransferAllCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}
